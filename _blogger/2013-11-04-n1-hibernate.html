---
layout: post
title: Решение проблемы N+1 в Hibernate
date: '2013-11-04T23:17:00.000+07:00'
author: Constantine Linnick
tags:
- работа
- orm
- development
modified_time: '2014-04-10T15:47:19.739+07:00'
thumbnail: http://2.bp.blogspot.com/-otIpSxxxB0U/Une7gfnhG5I/AAAAAAAACKY/nz-3eBv683g/s72-c/1.png
blogger_id: tag:blogger.com,1999:blog-372595778394672936.post-8706765383850562113
blogger_orig_url: http://blog.blzr.me/2013/11/n1-hibernate.html
---

<div dir="ltr" style="text-align: left;" trbidi="on"><h3 style="text-align: left;">Введение </h3>В нашем проекте для большинства сущностей их количество не превышает  сотни, а там где начинаются проблемы, хватает индексов - поэтому можно  не заморачиваться. Но тут внезапно появилась дичайшая просадка  производительности - клиент отваливался по таймауту на старте при  попытке запросить один справочник. Быстро выяснилось, что справочник  содержал 1000+ сущностей, на каждую из которых приходилось по пятку  дочерних на трех уровнях (да, это всё нужно было), в итоге это давало  несколько тысяч запросов при попытке сериализовать все это добро. Спойлер: в общем проблему за несколько часов удалось решить сократив количество запросов меньше чем до десяти.<br /><br />Если специально не заниматься оптимизацией, то ORM зачастую приводит к проблеме, называющейся "N+1": у нас имеются две связанные сущности (не важно 1-*, *-1 или 1-1) и дочерняя загружается лениво, то, при итерации по родительским сущностям и обращении к дочерним, будет в сумме N+1 обращений к базе, чтобы инициализировать ленивые прокси. Главное препятствие для лобового решения (вытянуть всё в один запрос) - то, что из-за пустых коллекций и null-ов некоторые или все джойны должны быть внешними, а разложить после этого результат по сущностям не получится. При маппинге мы разово указываем поведение коллекции LAZY или EAGER и тонко тюнинговать не получается. Разухабистая глава в документации Hibernate про <a href="http://docs.jboss.org/hibernate/orm/3.3/reference/en/html/performance.html#performance-fetching-custom">оптимизацию</a> не очень помогает. Вообще, проблема крайне <a href="https://www.google.ru/search?q=n%2B1+problem">распространенная</a>, может еще еще одно проявление <a href="http://en.wikipedia.org/wiki/Object-relational_impedance_mismatch">impendace mismatch</a>. Давно уже <a href="http://blog.blzr.me/2012/09/perfect-orm.html">писал</a> про ORM, ничего не поменялось, хотя уже почти не напрягает, за исключением отдельных случаев типа N+1.<br /><a name='more'></a><br /><h3 style="text-align: left;">В бой</h3>Итак, какое главное правило оптимизации? - Правильно, оптимизировать только боттлнеки, иметь метрику, которую можно измерить (масло масляное), и модель с воспроизводимым поведением. Первое налицо, метрикой будет - количество запросов.<br /><h4 style="text-align: left;">Как будем мерить?</h4>В Hibernate имеется <a href="http://docs.jboss.org/hibernate/core/3.6/javadocs/org/hibernate/stat/package-summary.html">Statistics API</a>. Включается он добавлением <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&lt;property name="hibernate.generate_statistics" value="true"/&gt;</span> в <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">persistence.xml</span>. Главной проблемой при использовании в JPA будет добраться до сессии из <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">EntityManager</span>: ограничиться <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">javax.persistenc</span>e не получится и придется кастовать к гибернейтовским классам, хотя мы уже используем внутренний нестандартный механизм поэтому пофиг. <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">((org.hibernate.Session) entityManager.getDelegate()).getSessionFactory().getStatistics(). </span>Еще одним минусом здесь будет глобальная статистика, хотя у нас будет модель и никто нам статистику внезапным желанием запросить насколько тысяч сущностей не подпортит.<br /><h4 style="text-align: left;">Модель</h4><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-otIpSxxxB0U/Une7gfnhG5I/AAAAAAAACKY/nz-3eBv683g/s1600/1.png" imageanchor="1" style="clear: right; float: right; margin-bottom: 1em; margin-left: 1em;"><img border="0" height="320" src="http://2.bp.blogspot.com/-otIpSxxxB0U/Une7gfnhG5I/AAAAAAAACKY/nz-3eBv683g/s320/1.png" width="177" /></a></div><div style="text-align: left;">Модель лежит у меня в песочнице, в пакете <a href="http://hg.blzr.me/sandbox/src/default/src/main/java/com/blazer/npo?at=default"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">com.blazer.npo.*</span></a>, запускабельный класс - <a href="http://hg.blzr.me/sandbox/src/default/src/main/java/com/blazer/npo/NPOApp.java?at=default">NPOApp</a>. Изврат с Guice можно проигнорировать: экспериментирую, как это удобно задействовать DI в нашем продукте - пока не очень удобно, видимо придется танцевать с дочерними модулями, AOP и кастомными Scope, поскольку стандарные плохо укладываются в философию Vaadin.<br /><br />Приложение стартует, заполняет тестовыми данными 5 сущностей на трех уровнях вложенности с различными взаимосвязями. Слой доступа к данным с запросами находится в <a href="http://hg.blzr.me/sandbox/src/default/src/main/java/com/blazer/npo/Dao.java?at=default">одноименном</a> классе. Тут хочется упомянуть давнюю проблему джавовых ORM-ов - именованные запросы находятся в сущностях, хотя в анемичном подходе запросы имеет смысл вынести туда, где они используются - в DAO слой. Есть простой хак: аннотировать DAO классы как <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">@MappedSuperclass</span>, еще есть <a href="https://hibernate.atlassian.net/browse/HHH-4140">тикет</a> 2005 года, who cares?</div><div style="text-align: left;"><br /></div><div style="text-align: left;">Задача простая: вытянуть Parent и обратиться ко всем дочерним объектам. Для этого используется <span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><a href="http://projectlombok.org/features/ToString.html">@ToString</a></span> от Lombok, после этого вызов <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">toString()</span> у родителя эффективно инициализирует всю иерархию. </div><h4 style="text-align: left;">Точка отсчета </h4><div style="text-align: left;">Получаем всех родителей и итерируем </div><pre><br /></pre><pre>for (Parent p : dao.parentsFindAll()) {<br />    log.trace(p.toString());<br />}</pre><div style="text-align: left;"><br />Процесс таков:<br />1. Запрашиваются <span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><b>Parent</b></span>: <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">select parent0_.id as id1_6_ from parent parent0_</span><br /><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><span style="font-family: inherit;">Дальше в цикле идет:</span></span><br /><br />2. Запрашивается один <b><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">ChildMtM</span></b>: <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">select childmtm0_.parent_id as parent_i1_6_1_, childmtm0_.child_id as child_id2_7_1_, childmtm1_.id as id1_2_0_, childmtm1_.value as value2_2_0_ from parent_child childmtm0_ inner join child_mtm childmtm1_ on childmtm0_.child_id=childmtm1_.id where childmtm0_.parent_id=?</span><br />3. Запрашивается один <b><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">ChildOtMNested</span></b>: <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">select nested0_.parent_id as parent_i3_2_1_, nested0_.id as id1_4_1_, nested0_.id as id1_4_0_, nested0_.parent_id as parent_i3_4_0_, nested0_.value as value2_4_0_ from child_otm_nested nested0_ where nested0_.parent_id=?</span><br />4. Запрашивается один <span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><b>ChildOtM</b></span>: <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">select childotm0_.parent_id as parent_i3_6_1_, childotm0_.id as id1_3_1_, childotm0_.id as id1_3_0_, childotm0_.parent_id as parent_i3_3_0_, childotm0_.value as value2_3_0_ from child_otm childotm0_ where childotm0_.parent_id=?</span><br />5. Заполняется <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">ChildOtO</span> для каждого элемента коллекции <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">ChildOtM</span>: <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">select childoto0_.id as id1_5_0_, childoto0_.parent_id as parent_i3_5_0_, childoto0_.value as value2_5_0_ from child_oto childoto0_ where childoto0_.parent_id=?</span><br /><br /><b>Total queries: 131</b></div><h4 style="text-align: left;">Наивный подход</h4><div style="text-align: left;">Первое, что я сделал, так это заранее выбрал все элементы.</div><pre><br /></pre><pre>dao.childMtMFindAll();<br />dao.childOtMFindAll();<br />dao.childOtOFindAll();<br />dao.childOtMNestedFindAll();<br />for (Parent p : dao.parentsFindAll()) {<br />    log.trace(p.toString());</pre><pre>}</pre><div style="text-align: left;"><br />Но, ожидаемого прироста не произошло:<br />1. <span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><b>ChildMtM</b>: select childmtm0_.id as id1_2_, childmtm0_.value as value2_2_ from child_mtm childmtm0_</span><br />2. <span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><b>ChildOtM</b>: select childotm0_.id as id1_3_, childotm0_.parent_id as parent_i3_3_, childotm0_.value as value2_3_ from child_otm childotm0_ </span></div>3. Инициализируется каждый <span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><b>ChildOtO</b>: select childoto0_.id as id1_5_0_, childoto0_.parent_id as parent_i3_5_0_, childoto0_.value as value2_5_0_ from child_oto childoto0_ where childoto0_.parent_id=? </span><br /><br />4. <span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><b>ChildOtO: </b>select childoto0_.id as id1_5_, childoto0_.parent_id as parent_i3_5_, childoto0_.value as value2_5_ from child_oto childoto0_</span><br />5. <span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><b>ChildOtMNested</b>: select childotmne0_.id as id1_4_, childotmne0_.parent_id as parent_i3_4_, childotmne0_.value as value2_4_ from child_otm_nested childotmne0_</span><br />6. <span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><b>Parent</b>: select parent0_.id as id1_6_ from parent parent0_</span><br />Предзагрузка кончилась, пошли итерации<br />7. <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">select childmtm0_.parent_id as parent_i1_6_1_, childmtm0_.child_id as child_id2_7_1_, childmtm1_.id as id1_2_0_, childmtm1_.value as value2_2_0_ from parent_child childmtm0_ inner join child_mtm childmtm1_ on childmtm0_.child_id=childmtm1_.id where childmtm0_.parent_id=?</span><br />8. <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">select nested0_.parent_id as parent_i3_2_1_, nested0_.id as id1_4_1_, nested0_.id as id1_4_0_, nested0_.parent_id as parent_i3_4_0_, nested0_.value as value2_4_0_ from child_otm_nested nested0_ where nested0_.parent_id=?</span><br />9. <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">select childotm0_.parent_id as parent_i3_6_1_, childotm0_.id as id1_3_1_, childotm0_.id as id1_3_0_, childotm0_.parent_id as parent_i3_3_0_, childotm0_.value as value2_3_0_ from child_otm childotm0_ where childotm0_.parent_id=?</span><br /><br /><b>Total queries 145</b><br /><br />Всё было плохо и стало еще хуже, вдумчивое курение сырцов и пошаговый дебаг выявил то, что коллекции и сущности кешируются в EntityManager отдельно, хотя, почему нельзя сначала выбрать первичные ключи и проверить PersistenceContext на предмет наличия в них сущностей мне непонятно. Можно было бы хинтом указать такое поведение, а потом пусть бы батч-фетчил недостающее если попадание больше 90% или запросил заново.<br /><h4 style="text-align: left;">Правильный путь</h4><div style="text-align: left;">Здесь мне уже надоело и стало скучно, в исходниках имеется еще два варианта на <b>105</b> и <b>15</b> запросов, кому интересно - посмотрят. Всю малину портит <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">ChildOtO</span>, который, как очевидно из названия, замаплен <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">@OneToOne</span>. На StackOverflow есть <a href="http://stackoverflow.com/questions/1444227/making-a-onetoone-relation-lazy">несколько</a> <a href="http://stackoverflow.com/questions/7025583/hibernate-onetoone-automatic-join-fetching-resolving-n1-problem">тем</a> посвященных этому больному вопросу. Важно его правильно замапить и вытягивать с заджойненно с родительской сущностью, а по-возможности избегать.</div><div style="text-align: left;"><br /></div><div style="text-align: left;">Запросы виде HQL выглядят так:</div><div style="text-align: left;">1.<span style="font-family: &quot;Courier New&quot;,Courier,monospace;"> Select p from Parent p LEFT JOIN FETCH p.childMtM c</span></div><div style="text-align: left;">2.<span style="font-family: &quot;Courier New&quot;,Courier,monospace;"> Select c from ChildMtM c LEFT JOIN FETCH c.nested n</span></div><div style="text-align: left;">3.<span style="font-family: &quot;Courier New&quot;,Courier,monospace;"> SELECT p FROM Parent p LEFT JOIN FETCH p.childOtM c JOIN FETCH c.nested n</span></div>4.<span style="font-family: &quot;Courier New&quot;,Courier,monospace;">  from Parent</span><br /><br /><b>Total queries 4. Flawless vitory.</b></div>