---
layout: post
title: Топологическая сортировка репозитория
date: '2013-05-07T18:32:00.000+07:00'
author: Constantine Linnick
tags:
- open source
- контроль версий
- development
modified_time: '2014-04-10T15:47:19.636+07:00'
thumbnail: http://1.bp.blogspot.com/-BVV92AM3eiQ/UYjN3x8UEOI/AAAAAAAAB10/Grgy1jNzQd8/s72-c/Screenshot+from+2013-05-07+15:34:36.png
blogger_id: tag:blogger.com,1999:blog-372595778394672936.post-2111117028538356289
blogger_orig_url: http://blog.blzr.me/2013/05/blog-post_7.html
---

<div dir="ltr" style="text-align: left;" trbidi="on"><h3 style="text-align: left;">Abstract</h3>В систему контроля версий <b>mercurial</b> версии 2.6 [<a href="http://mercurial.selenic.com/wiki/WhatsNew#Mercurial_2.6_.282013-05-01.29">1</a>] был добавлен новый алгоритм сортировки <b>closesort</b> в команду <b>convert</b>, позволяющий оптимизировать расположение коммитов, в которых закрываются ветки. В отличие от алгоритма <b>datesort</b>, который <i>might well increase the size of the destination repo by 10-20 times</i> [<a href="http://mercurial.selenic.com/wiki/ConvertExtension#A--branchsort.2C_--datesort.2C_--sourcesort">2</a>], <b>closesort</b> незначительно меняет размер репозитория. Данный алгоритм может быть интересен для workflow в которых активно ведется работа с ветвями, причем все открытые ветви закрываются.<br /><br /><h3 style="text-align: left;">Rationale</h3><table cellpadding="0" cellspacing="0" class="tr-caption-container" style="float: right; margin-left: 1em; text-align: right;"><tbody><tr><td style="text-align: center;"><a href="http://1.bp.blogspot.com/-BVV92AM3eiQ/UYjN3x8UEOI/AAAAAAAAB10/Grgy1jNzQd8/s1600/Screenshot+from+2013-05-07+15:34:36.png" imageanchor="1" style="clear: right; margin-bottom: 1em; margin-left: auto; margin-right: auto;"><img border="0" src="http://1.bp.blogspot.com/-BVV92AM3eiQ/UYjN3x8UEOI/AAAAAAAAB10/Grgy1jNzQd8/s1600/Screenshot+from+2013-05-07+15:34:36.png" height="320" width="320" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fig. 1 Визуальный мусор</td></tr></tbody></table><div style="text-align: left;">При активной работе с ветками рано или поздно может возникнуть ситуация, когда необходимо массово закрыть устаревшие ветви. Множество очень старых ветвей приводит к тому, что граф заполняется визуальным мусором. На Fig. 1 изображен типичный пример такой массовой чистки устаревших ветвей, на 1 живую ветвь приходится 15 мусорных.&nbsp;</div><div style="text-align: left;"><br /></div><div style="text-align: left;">Изменение порядка версий в большинстве случаев (сохранение хэшей между мажорными версиями mercurial не гарантируется) не будет влиять на хэши версий, поэтому такую сортировку можно периодический выполнять на центральном репозитории, при этом клиенты не заметят изменений, либо могут заново импортировать отсортированный репозиторий.</div><h3 style="text-align: left;">Methods</h3><div style="text-align: left;">Порядок версий необходимо менять, с использованием максимально  стандартного механизма, желательно с использованием внутреннего API, что  избавило бы от парсинга вывода команд. </div><h4 style="text-align: left;">Попытка 1</h4><div style="text-align: left;">Поиск готовых или похожих решений натолкнул на обсуждение [<a href="http://markmail.org/thread/vwtdmhigce3iatyy">3</a>] проблемы оптимизации чрезвычайно больших репозиториев, вылившихся в итоге в расширение shrink-revlog [<a href="http://selenic.com/hg/file/default/contrib/shrink-revlog.py">4</a>]. Данное расширение как раз занималось топологической сортировкой и достаточно было написать собственную функцию сортировки к двум имеющимся. Алгоритм был написан, при этом потребовалось прокинуть внутрь функции сортировки объект репозитория.</div><div style="text-align: left;"><br /></div><div style="text-align: left;">Но первый же запуск на реальном репозитории привел к ошибке выхода за пределы массива. Выяснилось, что в репозитории используется два файла changelog и manifest [<a href="http://mercurial.selenic.com/wiki/FileFormats?highlight=%28%5CbCategoryInternals%5Cb%29">5</a>]. В первом хранится информация о коммитах, а во втором информация о файлах [<a href="http://mercurial.selenic.com/wiki/Manifest?highlight=%28%5CbCategoryInternals%5Cb%29">6</a>], при этом, если в коммите не было изменений в файлах, то появится расхождение в нумерации между этими двумя файлами. Сортировка же changelog была запрещена, поскольку это повредит репозиторий.</div><h4 style="text-align: left;">Попытка 2</h4><div style="text-align: left;">В качестве "Плана Б" можно было встроиться в стандартное расширение convert. В нем уже присутствовали branchsort, datesort и sourcesort. Необходимый алгоритм отличался от sourcesort одним условием:<br /></div><div style="text-align: left;"><pre>        def makesourcesorter():<br />            """Source specific sort."""<br />            keyfn = lambda n: <b>self.commitcache[n].sortkey</b><br />            def picknext(nodes):<br />                return sorted(nodes, key=keyfn)[0]<br />            return picknext<br /><br />        def makeclosesorter():<br />            """Close order sort."""<br />            keyfn = lambda n: <b>('close' not in self.commitcache[n].extra,<br />                               self.commitcache[n].sortkey)</b><br />            def picknext(nodes):<br />                return sorted(nodes, key=keyfn)[0]<br />            return picknext </pre></div><div style="text-align: left;"><br /></div><div style="text-align: left;">И успешно решал поставленную задачу.</div><h4 style="text-align: left;">Pull request</h4><div style="text-align: left;">Я сразу пошел в IRC разработчиков с целью обсудить данное решение, но особого интереса там не проявили и отправили в мейллист. После этого, Kevin предложил попробовать branchsort [<a href="http://www.selenic.com/pipermail/mercurial-devel/2013-March/049750.html">7</a>]. Данный алгоритм упорядочивал только самые простые случаи, но не справлялся со сложными. На IRC мне посоветовали засылать патч, раз никто не возразил. Патч был заслан и запушен Bryan [<a href="http://www.selenic.com/pipermail/mercurial-devel/2013-March/049911.html">8</a>]. В этот раз на всё-про-всё, от идеи до аппрува, ушел всего лишь месяц, а не пол года, как в прошлый раз [<a href="http://blog.blzr.me/2012/02/hardest-piece-of-code-i-ever-wrote.html">9</a>].</div><h3 style="text-align: left;">Results</h3><h4 style="text-align: left;">Максимальная ширина </h4><div style="text-align: left;">На реальном рабочем репозитории с 5528 коммитов, максимальная ширина графа составляла 60 параллельных веток. После конвертации, ширина максимальная ширина репозитория уменьшилась до 26.</div><h4 style="text-align: left;">Средняя ширина</h4><div style="text-align: left;">Подсчет средней ширины графа производился командой <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">hg log -G | awk '/changeset/ {cnt++; width += (index($0,"changeset")-2)/2} END {print width / cnt}'<span style="font-family: Times,&quot;Times New Roman&quot;,serif;"></span></span>. Данная подсчет не учитывает некоторых особых случаев, но подойдет для примерной оценки. До конвертации 21.16 и после 6.08.</div><h3 style="text-align: left;">Discussion</h3><div style="text-align: left;">Алгоритм успешно, в разы сокращаяет ширину графа избавляя от визуального мусора. Из главных минусов можно указать то, что рассчет хэша у ревизии изменился между версиями 1.7 и 2.6, что приведет к несоответствию историй. Но, поскольку <i>repository surgery</i> можно проводить очень редко, это не является большой проблемой.</div></div>