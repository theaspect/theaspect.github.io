---
layout: post
title: Кровища и картины анальной боли
date: '2013-03-26T22:11:00.000+07:00'
author: Constantine Linnick
tags:
- боль
- тестирование
- development
modified_time: '2014-04-10T15:47:19.696+07:00'
thumbnail: http://4.bp.blogspot.com/-Zf14TPnRwSU/UVGlX2oMfYI/AAAAAAAABxE/1NgeESQCMME/s72-c/test.PNG
blogger_id: tag:blogger.com,1999:blog-372595778394672936.post-7065786488273350605
blogger_orig_url: http://blog.blzr.me/2013/03/blog-post_26.html
---

<div dir="ltr" style="text-align: left;" trbidi="on"><div class="separator" style="clear: both; text-align: center;"><a href="https://twitter.com/GoblinGame/status/314977191052070913" imageanchor="1" style="clear: right; float: right; margin-bottom: 1em; margin-left: 1em;"><img border="0" src="http://4.bp.blogspot.com/-Zf14TPnRwSU/UVGlX2oMfYI/AAAAAAAABxE/1NgeESQCMME/s400/test.PNG" height="400" width="328" /></a></div>Думать - больно: нужно прилагать усилия и тратить энергию, чтобы <a href="http://blog.blzr.me/2012/08/blog-post_10.html">разобраться</a>. Поэтому, развитие идет, если сохранять status quo еще больнее.<br /><a name='more'></a><h4 style="text-align: left;">Вводная</h4>Для нас переломным моментом стал сбор записей о звонках. Мы подключается через <a href="http://wiki.freeswitch.org/wiki/Event_Socket_Library">ESL</a> к Freeswitch и подписываемся на <a href="http://wiki.freeswitch.org/wiki/Event_list#Channel_events">события</a> которые льются непрерывным потоком вперемешку от разных событий. События крайне низкоуровневые вида: CHANNEL_CREATE (создан лег), CHANNEL_BRIDGE (два лега соединены), CHANNEL_HANGUP (лег завершен). Внутри каждого события имеется набор родных атрибутов, могут быть и наши, которые подсовываются в процессе генерации <a href="http://wiki.freeswitch.org/wiki/Dialplan_XML">диалплана</a>:<br /><br /><pre class="brush:java">Content-Length: 1754<br />Content-Type: text/event-plain<br /><br />Event-Name: CHANNEL_CALLSTATE<br />Core-UUID: f852daae-6da9-4979-8dc8-fa11651a7891<br />FreeSWITCH-Hostname: test<br />FreeSWITCH-IPv4: 1.2.3.4<br />FreeSWITCH-IPv6: %3A%3A1<br />Event-Date-Local: 2010-12-21%2014%3A21%3A54<br />Event-Date-GMT: Tue,%2021%20Dec%202010%2013%3A21%3A54%20GMT<br />Event-Date-Timestamp: 1292937714788536<br />Event-Calling-File: switch_channel.c<br />Event-Calling-Function: switch_channel_perform_set_callstate<br />Event-Calling-Line-Number: 213<br />Original-Channel-Call-State: HANGUP<br />Channel-State: CS_DESTROY<br />Channel-Call-State: DOWN<br />Channel-State-Number: 12<br />Channel-Name: sofia/internal_et/8000%40sipdomain.de<br />Unique-ID: 005f03fa-c803-428e-92cb-10534ac780dd<br />Call-Direction: inbound<br />Presence-Call-Direction: inbound<br />Channel-Presence-ID: 8000%40sipdomain.de<br />Answer-State: hangup<br />Channel-Read-Codec-Name: G722<br />Channel-Read-Codec-Rate: 16000<br />Channel-Read-Codec-Bit-Rate: 64000<br />Channel-Write-Codec-Name: G722<br />Channel-Write-Codec-Rate: 16000<br />Channel-Write-Codec-Bit-Rate: 64000<br />Caller-Direction: inbound<br />Caller-Username: 8000<br />Caller-Dialplan: LUA<br />Caller-Caller-ID-Name: Helmut%20Kuper<br />Caller-Caller-ID-Number: 8000<br />Caller-Network-Addr: 2.2.2.2<br />Caller-ANI: 8000<br />Caller-Destination-Number: ***6<br />Caller-Unique-ID: 005f03fa-c803-428e-92cb-10534ac780dd<br />Caller-Source: mod_sofia<br />Caller-Context: internal.lua<br />Caller-Channel-Name: sofia/internal_et/8000%40sipdomain.de<br />Caller-Profile-Index: 1<br />Caller-Profile-Created-Time: 1292937711184483<br />Caller-Channel-Created-Time: 1292937711184483<br />Caller-Channel-Answered-Time: 1292937711200482<br />Caller-Channel-Progress-Time: 0<br />Caller-Channel-Progress-Media-Time: 1292937711200482<br />Caller-Channel-Hangup-Time: 1292937714786536<br />Caller-Channel-Transfer-Time: 0<br />Caller-Screen-Bit: true<br />Caller-Privacy-Hide-Name: false<br />Caller-Privacy-Hide-Number: false<br /></pre><br />Жуткая мешанина свойств, большая часть из которых не документирована, в которых дублируются данные в разных атрибутах, иногда там оказывается совсем не то, что ожидается (вместо номера может попасть логин терминала), поменяться местами (номер терминала с именем пользователя), может прийти вообще мусор, есть очень похожие атрибуты, которые легко перепутать (caller, callee). Из этих сырых данных нужно было собирать высокоуровневую историю:<br />1. внешний номер позвонил на наш номер<br />2. попал в голосовое меню, побродил и выбрал связаться с оператором<br />3. попал в очередь<br />4. из очереди звонок забрал оператор первой линии и ответил<br />5. оператор звонит техническому специалисту и консультируется<br />6. оператор соединяет оба вызова и отключается<br />7. технический специалист разговаривает и просит прислать факсом документ<br />8. внешний номер перенаправляется на войсмейл специалиста<br />9. отправляет факс<br />10. вызов завершен<br /><br />Это, конечно, крайне экстремальный случай и большая часть вызовов будет состоять меньше чем из трех элементов, но держать в голове такие сценарии приходится (<i>А. Купер: программисты оперируют тремя числами: 0, 1 и ∞</i>).<br /><br /><h4 style="text-align: left;">Решение</h4><div style="text-align: left;">Главная проблема в том, что невозможно (proof me wrong) написать это stateless: высокоуровневая запись постепенно наполняется крохами данных, выдираемых из низкоуровневых событий. Отдельные события могут объединяться (6), из одной записи может рождаться другая (2), записи могут обмениваться информацией без слияния (8). Следовательно должен быть роутер, хранящий в себе состояние ведущихся звонков, передающий события для извлечения данных и опрашивающий на предмет готовности. Этот роутер должен быть крайне устойчивым: события могут не дойти из-за переполнения буфера, могут прийти лишние события, например, от потерянных ранее вызовов, иногда события приходят в неправильном порядке. Спасает то, что из потока событий можно извлекать паттерны размазанные по нескольким событиям: переводы вызова, звонки внутрь и наружу, работа с очередью и голосовым меню, конференции - главное все это правильно связать.</div><h4 style="text-align: left;">Fuzzy logic</h4><div style="text-align: left;">Stateful код сложно тестируем сам по себе. Но для того, чтобы жизнь не казалось слишком легкой, вскоре понадобилось заполнять события данными из базы. Вот есть строка. На всякий случай проверяем: не равна ли строка "xml" - вай-вай-вай, событие никуда не годится. Не совпало, отлично - пытаемся найти юзера с таким эксетншеном. Не получилось: быть может это логин терминала. Ну что ж, значит пусть это будет внешний номер, пишем как есть. На каждое событие несколько раз лазить в базу было очень плохой идеей, поэтому по максимуму упаковываем записи данными, и когда, запись полностью готова - разово заполняем её, перед сохранением. </div><h4 style="text-align: left;">Боль и унижение</h4><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/_InaQsFQD1kk/TVAk21VvKOI/AAAAAAAABJk/KDyamADtQP0/s1600/jenga-stacking.jpg" imageanchor="1" style="clear: right; float: right; margin-bottom: 1em; margin-left: 1em;"><img border="0" src="http://1.bp.blogspot.com/_InaQsFQD1kk/TVAk21VvKOI/AAAAAAAABJk/KDyamADtQP0/s320/jenga-stacking.jpg" height="320" width="240" /></a></div><div style="text-align: left;">В итоге у нас два слипшихся колобка спагетти правил с кучей проверок и переходов. Когда начали писать и сценариев был десяток это всё можно было протестировать руками. Но беглый набросок на бумаге выявил пол сотни. Код был чрезвычайно хрупок: малейшее изменение в логике при попытке починить сценарий херило корректную обработку всего остального. Время на добавление нового сценария росло экспоненциально (30 секунд на один сценарий * 50 сценариев = 25 минут). Плюс реальное тестирование не совместимо с отладкой: у сессии секундный таймаут и любая попытка поставить точку останова чтобы пройти по шагам и посмотреть, как роутятся события мгновенно разорвет сессию. Выбора не было - пришлось писать тесты. Каждый тест выглядел как YAML файл, который сам по себе был не слабой такой <a href="http://blog.blzr.me/2012/07/yaml.html">болевой</a> точкой. В файле сначала идет набор событий, затем - набор записей. События засылаются в роутер и на выходе сравниваются с требуемыми (процесс сравнения заслуживает <a href="http://blog.blzr.me/2013/04/blog-post_9.html">отдельного</a> поста).</div><h4 style="text-align: left;">Хрупкий код</h4><div style="text-align: left;">Хрупкий код приводит к хрупким тестам, и малейшие изменения в коде (добавлен новый атрибут) приводят к редактированию каждого из полусотни сценариев. Сейчас у нас уже четвертое ковровое переписывание сценариев, при этом обычный сценарий состоит из пятка событий на входе и парочки записей на выходе. Всё-же наличие тестов делает рефакторинг не таким страшным.</div><div style="text-align: left;"><br /></div><div style="text-align: center;"><b><a href="http://blog.blzr.me/2013/03/blog-post_28.html">Продолжение</a> с примерами кода</b></div></div>