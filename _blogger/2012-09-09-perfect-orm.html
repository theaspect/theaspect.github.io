---
layout: post
title: Perfect ORM
date: '2012-09-10T00:30:00.001+07:00'
author: Constantine Linnick
tags:
- development
modified_time: '2014-04-10T15:46:23.657+07:00'
blogger_id: tag:blogger.com,1999:blog-372595778394672936.post-6292637151470647180
blogger_orig_url: http://blog.blzr.me/2012/09/perfect-orm.html
---

<div dir="ltr" style="text-align: left;" trbidi="on">Посмотрел два интересных видео. Первое про дотнет и про то как там у разработчиков волосы гладкие и шелковистые, а второе про хибернейт и как там все ужасно. Давно хотел сформулировать свое отношение и вот созрело, хоть и немного сумбурно.<br /><br /><a name='more'></a><br /><div dir="ltr" style="text-align: center;" trbidi="on"><iframe allowfullscreen="allowfullscreen" frameborder="0" height="281" mozallowfullscreen="mozallowfullscreen" src="http://player.vimeo.com/video/33022539?portrait=0&amp;color=ffffff" webkitallowfullscreen="webkitallowfullscreen" width="500"></iframe><br /><br /><iframe frameborder="0" height="254" src="http://video.yandex.ru/iframe/xpinjection/vrk15k93wt.5002/" width="450"></iframe><br /></div><h3 style="text-align: left;">JDBC </h3><br />На первом проекте мы использовали чистый JDBC, выкладывая данные напрямую в JSP. Через пару лет мы доросли до предварительной выгрузки в POJO и то, только потому, что это было удобно сериализовать в JSON. У нас было несколько проблем:<br />1. Мы использовали хранимки на PL/SQL и Oracle-специфичную работу с кубами, и не смогли перейти на PostgreSQL, когда пытались уменьшить стоимость продукта.<br />2. Пул коннектов, который регулярно приходилось подкручивать.<br />3. Место хранения запросов. Некоторые запросы были настолько огромные, что мы хранили их в отдельных файлах. Многострочных строк в жабе реально не хватало. В итоге логика размазалась между хранимками, файлами и кодом.<br /><br />Под конец я пытался как-то унифицировать выкладку данных из запроса в&nbsp; POJO, но не преуспел в связи с отсутствием опыта работы с reflection.<br /><h3 style="text-align: left;">Django ORM</h3><div style="text-align: left;">На втором проекте долго выбирал на чем писать веб часть. Пэхапешный <a href="http://www.yiiframework.com/">Yii</a> был великолепен, но сам PHP вызывал у меня почти физическое страдание. Решил использовать питоновский <a href="https://www.djangoproject.com/">Django</a>. У него был простой ORM. Благодаря динамичности он упрощал тривиальные случаи и не препятствовал сложной логике благодаря <a href="https://docs.djangoproject.com/en/dev/topics/db/managers/">Manager</a>-ам. Кому было тесно в рамках родного ORM, мог подключить <a href="http://www.sqlalchemy.org/features.html">SQLAlchemy</a>.</div><div style="text-align: left;"><br /></div><div style="text-align: left;">Единственная проблема, с которой я столкнулся - это отсутствие <a href="https://code.djangoproject.com/ticket/2238">реверсивной подгрузки</a>. Комментарии к тикету довольно показательны. В рельсах это работало, а в Django положили на проблему большой wontfix.</div><h3 style="text-align: left;">JPA over Hibernate</h3><h4 style="text-align: left;">Главные аргументы за ORM? </h4><div class="separator" style="clear: both; text-align: center;"><a href="http://cdn.memegenerator.net/instances/400x/26439437.jpg" imageanchor="1" style="clear: right; float: right; margin-bottom: 1em; margin-left: 1em;"><img border="0" height="240" src="http://cdn.memegenerator.net/instances/400x/26439437.jpg" width="320" /></a></div><div style="text-align: left;">1. Можно не знать SQL? Полный буллшит, <a href="http://russian.joelonsoftware.com/Articles/LeakyAbstractions.html">абстракция течет</a> из всех щелей.</div><div style="text-align: left;">2. Мы абстрагируемся от базы? Тоже бред, на более-менее сложных запросах мы будем вынуждены писать чистый SQL, а в процессе оптимизации еще и использовать DB-specific оптимизации.</div><div style="text-align: left;">3. Можно не задумываться об управлении объектами? То количество времени, которое мы потратили на борьбу с ленивой инициализацией и закрытими сессиями не поддается подсчету.</div><div style="text-align: left;">4. Перегрузка данных из базы в объекты и назад - это, пожалуй единственное что удалось реализовать. Да и та делается через reflection.</div><h4 style="text-align: left;">Что мы теряем?&nbsp;</h4><div style="text-align: left;">1. Простой и оптимизированный SQL. Выбирается огромный объем данных, отсутствует возможность тонкого управления ленивой инициализацией. Да и сама ленивая инициализация это - костыль.</div><div style="text-align: left;">2. Невозможность поточной выгрузки большого количества объектов, например тысячи точек для построения графиков.</div><div style="text-align: left;">3. Сложные случаи делаются почесыванием правой пяткой за левым ухом, либо плюём и пишем чистый SQL.</div><h3 style="text-align: left;">Альтернативы для Java</h3><div style="text-align: left;">Судя по <a href="http://stackoverflow.com/questions/452385/what-java-orm-do-you-prefer-and-why">этой ветке</a> на stackoverflow, единственная серьезная альтернатива гибернейту на Java - <a href="http://blog.mybatis.org/">MyBatis</a>. Но и он точно так же завалится на сложных случаях. Остальные, типа <a href="http://www.playframework.org/documentation/2.0/JavaEbean">Ebean</a> в Play! недостаточно взрослые.</div><h3 style="text-align: left;">Что хочется от идеального ORM</h3><div style="text-align: left;">0. Отсутствие ORM.</div><div style="text-align: left;">1. Использование чистого SQL, возможно имеет смысл покрывать тестами для удобства потенциальной миграции</div><div style="text-align: left;">2. Перегрузка данных между объектами и resultset</div><div style="text-align: left;">3. Возможность низкоуровнего доступа к resultset для тонкой работы с данными</div><div style="text-align: left;">4. Поточная работа с resultset, без промежуточного создания кучи объектов</div><div style="text-align: left;">5. Многоэтапная выгрузка объектов из базы и хуки для ленивой подгрузки</div></div>