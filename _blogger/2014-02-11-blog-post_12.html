---
layout: post
title: Прикладная топология в исходном коде
date: '2014-02-12T01:19:00.001+07:00'
author: Constantine Linnick
tags:
- боль
- работа
- development
- epiphany
modified_time: '2014-04-10T15:47:19.719+07:00'
blogger_id: tag:blogger.com,1999:blog-372595778394672936.post-8302296137192997351
blogger_orig_url: http://blog.blzr.me/2014/02/blog-post_12.html
---

<div dir="ltr" style="text-align: left;" trbidi="on"><h4 style="text-align: left;">Не развидеть </h4><div style="text-align: left;">Бывают такие вещи, которые, однажды увидев, начинаешь замечать абсолютно везде. Для меня недавно таким <a href="http://blog.blzr.me/2013/09/java.html">открытием</a> были теги <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">{@see}</span> и <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">{@link}</span> в джавадоках. Я неистово стал превращать исходники в такую вики. Параллельно сделал другое открытие, код не <a href="http://burrarum.livejournal.com/52064.html">изотропен</a>, связность пространства нарушается: попав из точки А в точку Б, я не всегда могу вернуться назад с той же скоростью - приходится обходить иерархию или вспоминать назание класса (черт возьми, у меня в активной памяти буфер на 7 элементов, названия класса из него выталкивается, даже если я пререшел из него десять секунд назад), чтобы по <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">Ctrl+N</span> перейти на него. Тут не спасают даже линки в джавадоках. Дальше я собрал подборочку таких моментов с реальными примерами.</div><a name='more'></a><br /><h4 style="text-align: left;">Ссылки на файлы</h4><div style="text-align: left;">В IntelliJ IDEA нельзя поставить ссылку на произвольный файл. Есть несколько <a href="http://youtrack.jetbrains.com/issue/IDEA-113847">фичреквестов</a>, но статус их непонятен. Это позволило бы доступаться к файлам ресурсов хотя бы в одностороннем направлении.</div><div style="text-align: left;"><br /></div><div style="text-align: left;">Вообще ресуры - больная тема. Мы конечно можем себя убеждать, что ресурсы можно редактировать отдельно специальными людьми, но реальность прозаична. Поправив строчку в текстовом файлике с локализацией, мы пушим изменения на CI и через двадцать минут он выплевывает в репозиторий инсталлятор с полугиговым убер-варником.</div><div style="text-align: left;"><br /></div><div style="text-align: left;">Для локализации мы используем <a href="https://github.com/lightoze/gwt-i18n-server">gwt-i18-server</a>. Конечно мы тешим себя мыслью, что когда-нибудь у нас будет куча языков, но сейчас у нас их два и необходимо тратить время на синхронизацию изменений, перемещать их, если переместил интерфейс, создавать. Единственная оптимизация, которую я вижу - выделить имя класса и нажать ctrl+shift+n, чтобы быстро открыть оба два проперти файла с локализованными строкам. Здесь полный разрыв между двумя сущностями, которые должны быть рядом. Тут бы помогли аннотации (кстати идея для пулл реквеста).</div><div style="text-align: left;"><br /></div><div style="text-align: left;">Та же фигня со <a href="https://vaadin.com/book/-/page/themes.html">стилями</a> в Vaadin. Есть файлик типа ReindeerTheme.java в котором куча строк вида <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">public static final String MY_SUPER_BUTTON_STYLE = "my-super-button-style"</span>. Эти стили описаны в файле ресурсов style.css. Константы это, конечно, прикольно, но из этого файла никак не попасть в файл со стилями. А то, что написано в константах вообще никак не связано с тем, что написано в файле со стилями.</div><h4 style="text-align: left;">Статическая компиляция и reflection</h4><div style="text-align: right;"><i>Every time, you use reflection&nbsp;</i></div><div style="text-align: right;"><i>to workaround language limitation,&nbsp;</i></div><div style="text-align: right;"><i>somewhere, somehow God kills kitten</i></div><div style="text-align: left;"></div><div style="text-align: left;"><br /></div><div style="text-align: left;">Вообще, мне очень нравится статически проверяемый код (до haskell я еще не дорос) и я здесь говорю гораздо шире чем типы. Вот между перечнем стилей и описанием стилей не было никакой связи. Компилятор никак не поможет, если программист где-то опечатался. Я бы лучше написал какой-нибудь генератор стилей в стиле fluent builder и был спокоен. Наличие же такой связи иногда позволяет избавиться от множественного редактирования.</div><div style="text-align: left;"><br /></div><div style="text-align: left;">Иногда рефлекшен это как головоломка, позволяет почесать правой пяткой за левым ухом. Иногда он приводит к очень элегантным решениям проблем. Но в большинстве случаев необдуманное использование reflection - это зло. Не потому, что, ой-ой, программа начинает тормозить - за многослойным наполеоном из спринбернейтов доступание к полям бина по имени дает пренебрежимо мало. Главное зло здесь в том, что рвется связь между именем поля и полем. Отличный пример Vaadin Bean Validation написанный поверх JSR-303. <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">BeanValidationValidator.addValidator (Field field, Object propertyId, Class&lt;?&gt; beanClass)</span>. Между propertyId и beanClass нет никакой связи. И если вдруг разработчик исправил опечатку в имени поля, то валидатор не будет найдет. То же самое и с <a href="https://vaadin.com/book/-/page/datamodel.items.html">моделью данных</a> в Vaadin. В java 7 появятся долгожданные лямбды и ссылки на функции, которые можно будет использовать в биндинге данных: указывать не проперти а ссылки на геттеры и сеттеры. Рефакторинг переименовывания поля (который также затрагивает геттеры и сеттеры) будет абсолютно безопасными.</div><div style="text-align: left;"><br /></div><div style="text-align: left;">В Vaadin 6 разработчики еще не вкурили генерики (может была и другая причина) и фигачили все на Object, из-за чего постоянно приходилось конвертить типы. В седьмой версии финны <a href="https://vaadin.com/vaadin7">одумались</a> и вкорячили генерики в модель данных, растоптав надежду обратную своместимость.&nbsp;</div><div style="text-align: left;"><br /></div><div style="text-align: left;">Мощь генериков начала до меня доходить только недавно, жаль что в 8-ке не осилили убрать type erasure - это бы сильно облегчило жизнь и не надо было бы использовать хаки с наследованием, которые закладывались на жесткий порядок типов, когда неосторожное наследование приводит к трудноотлавливаемым ошибкам.</div><div style="text-align: left;"><br /></div><div style="text-align: left;">Еще один плагин, который и привел к идее ссылок <a href="https://github.com/panter/org.vaadin.mvp">org.vaadin.mvp</a>. События описываются в шине как&nbsp;</div><div style="text-align: left;"><br /></div><div style="text-align: left;"></div><div class="line" id="LC16"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><span class="nd">@Event</span><span class="o">(</span><span class="n">handlers</span> <span class="o">=</span> <span class="o">{</span> <span class="n">MenuPresenter</span><span class="o">.</span><span class="na">class</span> <span class="o">})</span></span></div><div class="line" id="LC17"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><span class="kd">public</span> <span class="kt">void</span> <span class="nf">selectMenu</span><span class="o">(</span><span class="n">ValueChangeEvent</span> <span class="n">event</span><span class="o">);</span></span></div><br /><div style="text-align: left;"><br /></div><div style="text-align: left;">Вся эта магия работает через рефлекшен. Проблема в том, что в презентере должен быть метод onSelectMenu(...). Это рвет связь между методом и подписчиком. Опечатки, ручные переименования, копирование и вставка с переименование. Метод обязательно дожен быть публичным и прочее веселье. Чтобы не было предупреждений, метод нужно помечать&nbsp;<span style="font-family: &quot;Courier New&quot;,Courier,monospace;">@SuppressWarnings("unused")</span>, что опять же плохо, ведь он может перестать использоваться на самом деле. <a href="http://code.google.com/p/guava-libraries/wiki/EventBusExplained">Гуавовская шина</a> мне импонирует гораздо больше.</div><h4 style="text-align: left;">JPA</h4><div style="text-align: left;">Главная проблема - где хранить запросы к базе. Проблема связности меня <a href="http://blog.blzr.me/2013/04/blog-post_21.html">беспокоила</a> с самого начала карьеры, хотя я и не мог её сформулировать, но понимал, что что-то здесь не так. Итак, мы пришли к анемичной доменной модели: есть классы, в которых хранятся значения и самая минимальная бизнес-логика и сервисный слой, который оперирует с доменами. Нам говорят: храните запросы в <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">@NamedQuery</span> в доменных объектах. Но в нашей ситуации запросы используются в сервисном слое. Типичный воркфлоу: добавляем запрос в домен, добавляем метод в сервисный класс. Когда попал в сервис, чтобы посмотреть на запрос нужно открывать домен, если исправил запрос в домене нужно открывать сервис и править там. Вотафак.</div><div style="text-align: left;"><br /></div><div style="text-align: left;">Почему не перенести запросы туда, где они используются (because fuck you, <a href="https://hibernate.atlassian.net/browse/HHH-4140">критический баг</a> открыт 8 лет назад). На самом деле можно сервис аннотировать @MappedSuperclass, что позволит переместить запросы в один файл с тем местом где они используются. Хотелось бы переместить их непосредственно в метод, но увы, мы тогда потеряем валидацию JPQL на этапе компиляции, а этого очень не хочется.</div><div style="text-align: left;"><br /></div><div style="text-align: left;">Когда на этапе компиляции запрос не проходит валидацию, то гибернейт вывливает дикий стектрейс. Есть маленькая проблема, из окна логов нельзя попасть непосредственно в класс, содержащий проблемный запрос.</div><h4 style="text-align: left;">Тесты</h4><div style="text-align: left;"></div><div style="text-align: left;">Нельзя поставить ссылку из класса на тест для этого класса, хотя это очень естественное желание - после редактирования исходника, перейти в файл с тестами чтобы посмотреть на варианты использования, либо поправить сценарии, но IDEA не видит тестовых классов.</div><h4 style="text-align: left;">FXML</h4><div style="text-align: left;">Декларативный гуй для JavaFX внутри XML. Если не брать во внимание, что он дичайше тёк и парсил XML на каждую отрисовку компонента, то это отличная иллюстрация разрыва. Разрыва между двумя сущностями, которые должны быть рядом. Я добавил компонент, добавил клик-лисенер. Потом мне нужно найти класс, вспомнить сигнатуру!, прописать её руками. Да нахрен оно мне надо <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">Button b = ButtonBuilder.create().onClick(...)</span>. Билдеры для каждого компонента вообще мегаудобная штука, позволяет писать многоуровневые цепочки в стиле JQuery. Где-то даже видел расстройство: мол разработчики фигачать гуй в коде и не используют такой удобный Scene Builder. Потому и не используют, что небольшая экономия на старте обернется большими затратами времени в сопровождении.<br /><h4 style="text-align: left;">Потеря контекста в тредах</h4><div style="text-align: left;">Если в треде происходит исключение, то стек трейс начинается с создания Экзекутора. Нам же, как правило, интересно кто создал этот таск. Очень удобно оказалось создавать исключения в конструкторе и выводить оригинальный стек трейс при возникновении исключения в треде.</div><div style="text-align: left;"><br /></div><div style="text-align: left;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">public class Task implements Runnable {<br />&nbsp;&nbsp;&nbsp; private Exception context = new Exception();<br /><br />&nbsp;&nbsp;&nbsp; public void run() {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try {</span></div><div style="text-align: left;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...</span></div><div style="text-align: left;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } catch (Exception e) {<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; log.error("Cannot upload", e);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; log.debug("Context", context);<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />&nbsp;&nbsp;&nbsp; }<br />}</span></div></div><h4 style="text-align: left;">Мусор</h4><div style="text-align: left;">Из-за разрывов мы не можем быстро и с уверенностью делать вывод о том, что конкретный ресурс или строка локализации не используется. Спустя какое-то время в проекте начинает копиться мусор, чтобы его вычистить нужно затратить значительные услилия, хотя обычно забивают.</div><h4 style="text-align: left;">&nbsp;Выводы</h4><div style="text-align: left;">Если сущности зачастую редактируются одновременно, то они должны находится как можно ближе друг другу, но не настолько близко чтобы все смешалось в кучу. Двусторонний переход в один клик - это удобно.</div><div style="text-align: left;"><br /></div><div style="text-align: left;">Статическая типизация увеличивает связность и уменьшает количество ошибок из-за рассинхронизации сущностей.</div></div>