---
layout: post
title: Про лямбды и API
date: '2014-03-09T02:09:00.001+07:00'
author: Constantine Linnick
tags:
- работа
- development
- epiphany
modified_time: '2014-04-10T15:47:19.698+07:00'
blogger_id: tag:blogger.com,1999:blog-372595778394672936.post-7107294730938202724
blogger_orig_url: http://blog.blzr.me/2014/03/api.html
---

<div dir="ltr" style="text-align: left;" trbidi="on"><h3 style="text-align: left;"><a href="http://www.lambdafaq.org/wp-content/themes/atahualpa/images/lambda-e1349128159649.png" imageanchor="1" style="clear: right; float: right; margin-bottom: 1em; margin-left: 1em;"><img border="0" src="http://www.lambdafaq.org/wp-content/themes/atahualpa/images/lambda-e1349128159649.png" /></a>Dive into lambdas</h3>Наконец-то добрались руки чтобы пощупать такие долгожданные лямбды, качнул свеженькую восьмерку и набросал некоторые варианты использования, которые могут быть полезны для увеличения <a href="http://blog.blzr.me/2014/02/blog-post_12.html">связности</a> кода. Сходу набросал три примера, сырцы в <a href="http://hg.blzr.me/sandbox/src/default/src/main/java/com/blazer/lambda/LambdaDemo.java?at=default">песочнице</a>.<br /><a name='more'></a><br /><h4 style="text-align: left;">Method reference vs BeanInfo</h4><div style="text-align: left;">Старый способ - получать геттеры и сеттеры по строковому имени через <a href="http://docs.oracle.com/javase/7/docs/api/java/beans/Introspector.html">Introspector</a>. Все работает, до первого переименования поля в классе, пока мы не начинаем получать WTF в коде.</div><div style="text-align: left;"><br /></div><div style="text-align: left;">С новым способом мы можем рефакторинго-безопасно передавать ссылки на методы. Смотри код <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">methodAccessorsDemo</span>. Причем передавать можем двумя способами: в виде lambda и в виде closure. И если с первым спомобом все понятно: есть экземпляр объекта, и метод, который у него вызывается, то второй способ полнейший разрыв мозга: передача метода через Тип, а не экземпляр. Долго курил, пока не понял, что если в <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">functionalInterfaceMethod(a,b)</span> мы передаем <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">concreteMethod(b)</span> с одним параметром, то конпелятор развернет это в <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">a.concreteMethod(b)</span>. Очень неочевидно, напоминает питоний <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">Self</span>, подробнее про это <a href="http://www.lambdafaq.org/what-is-the-syntax-for-instance-method-references/">здесь</a>.</div><h4 style="text-align: left;">Lazy evaluation</h4><div style="text-align: left;">Ленивые вычисления. Один раз столкнулся, когда писал <a href="http://ru.wikipedia.org/wiki/Fluent_interface">FluentBuilder</a>: очень часто была проверка на истинность и выполнение тех или иных действий. В простейших случаях было нормально, но только до первой проверки на <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">null</span>: <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">doIf(a != null, a.name(), b.name())</span>. Очень красиво, но сходу ловишь <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">NPE</span>: перед вызовом метода все фактические параметры должны быть вычислены. Но если у нас есть лямбды то можно переписать, не теряя лаконичности: <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">doIf(a != null, () -&gt; a.name(), </span><span style="font-family: &quot;Courier New&quot;,Courier,monospace;"><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">() -&gt; </span>b.name())<span style="font-family: inherit;">. Когда писал, увидел, что в примере не возвращаются параметры, но это решается заменой <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">Runnable</span> на <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">Callable</span>.</span></span></div><h4 style="text-align: left;">AOP</h4><div style="text-align: left;">Нормальный такой AOP без всяких аннотаций. Можно использовать для всех классических применений: логирование, транзакции, контракты, проверка прав доступа. В примере просто логирую значение до и после вызова метода.</div><h3 style="text-align: left;">API</h3><div style="text-align: left;">Зачем все эти танцы с бубном вокруг лямбд для простого пользователя? Есть же стандартные вещи типа коллекций, событий, зачем городить свои огороды? У меня необратимые изменения в мозге появились, когда я зачем-то заглянул в код Guava. Вернее сначала увидел <a href="http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/collect/ImmutableList.html#of%28%29">ImmutableIist.of(...)</a>, очень сильно удивился (ну ведь не дураки же писали, значит зачем-то нужно), полез в смотреть в сырцы и бездны ада взглянули на меня. Затем, мне очень понравился <a href="http://code.google.com/p/guava-libraries/source/browse/guava/src/com/google/common/base/Joiner.java">Joiner</a>, то как он сохраняет контекст. Целиком впитав эту идею, я проникся и понял: чтобы в основном коде лаконично, читаемо, в одну строку выражать мысли <a href="http://code.google.com/p/guava-libraries/wiki/StringsExplained#Joiner">типа</a> <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">Joiner.on(",").join(Arrays.asList(1, 5, 7))</span>, где-то придется устроить Адъ и Израиль на пол тысячи строк. Последнее время очень активно ощупываю границы применимости, пока очень доволен. IntelliJIDEA уже давно сворачивает анонимные классы до лямбд и синтаксис уже совершенно привычен. Когда же до debian доедет восьмерка, можно будет совершенно легально их использовать.</div></div>