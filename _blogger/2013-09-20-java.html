---
layout: post
title: Гипертекстовый код на Java
date: '2013-09-20T21:45:00.000+07:00'
author: Constantine Linnick
tags:
- мысли
- работа
- development
- epiphany
modified_time: '2014-04-10T15:47:19.748+07:00'
blogger_id: tag:blogger.com,1999:blog-372595778394672936.post-8960278372107968332
blogger_orig_url: http://blog.blzr.me/2013/09/java.html
---

<div dir="ltr" style="text-align: left;" trbidi="on">В любой уважающей себя <a href="http://www.jetbrains.com/idea/">IDE</a> есть ctrl+click-to-go, когда можно щелкнуть на переменной и перейти к объявлению, щелкнув на методе - перейти в его реализацию, щелкнув на классе перейти в это класс. Тривиальнейшая и очевиднейшая вещь воспринимается как должное, <strike>пока не сядешь за какой-нибудь Visual Studio Express, где её почему-то нет</strike> поправка: в VS есть F12 (Eclipse и NetBeans это умеют, но зачем ездить на жигулях, если есть бесплатный кадиллак). Но мы не будем рассматривать отщепенцев.<br /><br />Зачастую положительные изменения не происходят, пока не преодолен некий болевой порог. Неудобство воспринимается как должное. Когда наконец происходит СУКАБЛЯЗАЕБАЛОАЖБЕСИТ начинаешь что-то думать. Наступает эдакий момент откровения.<br /><a name='more'></a><br /><h4 style="text-align: left;">@see</h4>В контексте поста впервые у меня это произошло при дебаге шины событий в <a href="http://org.vaadin.mvp/">org.vaadin.mvp</a>. Вот <a href="http://code.google.com/p/guava-libraries/wiki/EventBusExplained">описание</a> принципа на примере гугловой Гуавы. Вкратце: есть шина в виде интерфейса, на методы которого через аннотацию навешаны классы-подписчики получающие уведомления о событиях. Единственная проблема: если метод в шине называется <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">fooEvent(Bar bar)</span>, то в подписчике этот метод должен называться <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">onFooEvent(Bar bar)</span>. Поскольку в шине указаны конкретные классы то можно click-to-go и перейти в класс, ладно уж не на конкретный метод. А вот назад перейти нельзя - и этот односторонний тоннель реально начинает накалять, когда хочется прыгнуть назад и перейти в другого подписчика.<br /><br />Решение очень простое: добавить <a href="http://www.oracle.com/technetwork/java/javase/documentation/index-137868.html#@see">@see</a> или <a href="http://www.oracle.com/technetwork/java/javase/documentation/index-137868.html#{@link}">{@link}</a> на шину, чтобы в одно нажатие вернуться назад. Со временем код начинает обрастать такими тоннелями: нужно быстро подсмотреть пример реализации - {@link}, нужна ссыка на спецификацию - <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&lt;a href&gt;</span>. Мгновенная телепортация в нужно место это круто. Сегодня поймал себя на том, что поставил ссылку внутри одного файла: фрагмент кода находился не там где я его ожидал увидеть. Перед методом, кстати было пояснение, какого, собственно, хрена он находится не там где ему положено быть - очень полезное требование обязательного пояснения неочевидных решений, чтобы кто-нибудь не попытался с наскоку чинить. Так сразу понятно: человек так сделал отдавая себе отчет в том что он делает. В общем поставил ссылку на метод в то место, где по-умолчанию будут его искать.<br /><h4 style="text-align: left;">@deprecated</h4>Джавадоки вообще полезнейшая штука. На втором месте после линков у меня стоит аннотация <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">@Deprecated</span> и одноименный тег в джавадоке. В исходнике классы, методы, переменные будет зачеркнуты, что само по себе должно вызвать сомнения в целесообразности их использования. Хорошим тоном является в джавадоке пояснить - почему это не рекомендуется применять и что использовать вместо. Иногда как deprecated помечаются внутренние методы, которые почему-то не были сделаны приватными.<br /><br />В том же mvp есть FactoryPresenter с переменной, которую по-задумке должны использовать потомки. К сожалению, после изменения логики, это переменной стало нельзя пользоваться. Но как защититься от случайного использования? Добавить в наследнике переменную, хоторая перекроет родительскую и пометить её как deprecated:<br /><br /><span style="font-family: &quot;Courier New&quot;,Courier,monospace;">&nbsp;&nbsp;&nbsp; /** @deprecated never use this field and do not delete this warning, use getPresenterFactory() instead */<br />&nbsp;&nbsp;&nbsp; @Deprecated<br />&nbsp;&nbsp;&nbsp; @SuppressWarnings("unused")<br />&nbsp;&nbsp;&nbsp; protected OrangeucePresenterFactory presenterFactory = null;</span><br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://24.media.tumblr.com/7871642ebd8dcfe3a60693b074ff0a02/tumblr_mjrer7T3391s5h9kdo1_500.gif" imageanchor="1" style="clear: right; float: right; margin-bottom: 1em; margin-left: 1em;"><img border="0" height="180" src="http://24.media.tumblr.com/7871642ebd8dcfe3a60693b074ff0a02/tumblr_mjrer7T3391s5h9kdo1_500.gif" width="320" /></a></div>Как же приятно читать такие послания из прошлого - прям чувствуешь, как пара строк экономит уйму времени на борьбу с вотзефаком.</div>