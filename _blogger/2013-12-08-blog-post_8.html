---
layout: post
title: Оптимизация страничной выборки со сложной фильтрацией
date: '2013-12-08T04:39:00.000+07:00'
author: Constantine Linnick
tags:
- работа
- orm
- development
modified_time: '2014-04-10T15:47:19.736+07:00'
blogger_id: tag:blogger.com,1999:blog-372595778394672936.post-8559732677723295895
blogger_orig_url: http://blog.blzr.me/2013/12/blog-post_8.html
---

<div dir="ltr" style="text-align: left;" trbidi="on">В продолжение темы о решении <a href="http://blog.blzr.me/2013/11/n1-hibernate.html">проблемы N+1 в Hibernate</a>.<br /><h4 style="text-align: left;">Постановка задачи</h4><div style="text-align: left;">Нужно сформировать отчет, содержащий 100к строк и фильтрацию по нескольким полям. Выборка объективно не укладывается в отведенные рамки: годовая выборка - 30 секунд. Приходится грузить данные на клиента маленькими чанками по сто записей. При этом мы столкнулись с тем, что один чанк загружается в течении 2 секунд, помножив на 1000 чанков получаем более получаса на получение отчета. Вся выборка ведется по двум таблицам в отношении One-to-Many, причем Many часть почти на 100% состоит из 1 записи, но СЦУКО могут встречаться &gt; 1.</div><div style="text-align: left;"></div><a name='more'></a><br /><h4 style="text-align: left;">Оптимизация выборки окна</h4><div style="text-align: left;">Мы оптимизировали выборку предзагрузив необходимые данные и у нас нет коррелированных подзапросов. Но при добавлении в запрос содержащий <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">LEFT JOIN FETCH</span> окна <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">query.setFirstResult(start).setMaxResults(100);</span> Hibernate плевался ворнигом <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">HHH000104: firstResult/maxResults specified with collection fetch; applying in memory!</span> что, в общем-то, логично: из-за <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">OUTER JOIN</span> он не может рассчитать ни начало выборки, ни необходимое количество записей, поэтому он выбирал все данные, и только потом ограничивал окно.</div><div style="text-align: left;"><br /></div><div style="text-align: left;">На StackOverflow предложили оригинальное решение проблемы: так как окно небольшое, то сначала выбираем первичные ключи <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">SELECT DISTINCT p.id FROM Parent p LEFT JOIN p.child c WHERE p = ... and c = ... ORDER BY p.timestamp</span>, а затем выбираем данные фильтруя по полученным идентификаторам <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">SELECT DISTINCT p FROM Parent p LEFT JOIN FETCH p.child c WHERE p.id IN (?) ORDER BY p.timestamp</span>.</div><h4 style="text-align: left;">Bottleneck</h4><div style="text-align: left;">Хак с выборкой первичных ключей помог, но все равно производительности сильно не хватало. Мы начали искать затык и, спустя какое-то время, удалось изолировать момент проседания производительности. Время запроса <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">SELECT p.* FROM parent p LEFT JOIN child c on p.id = c.id WHERE p.timestamp BETWEEN ? AND ? ORDER BY p.timestamp</span> отличался от аналогичного с <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">DISTINCT </span>более чем в 100 раз. Оптимизатор MariaDB во втором запросе терял индекс, начиная яростно фуллсканить.</div><h4 style="text-align: left;">Оптимизации</h4><div style="text-align: left;">После серьезного мозгового штурма мы нашли способ укорить запрос еще в пять раз, отказавшись от небольшого допущения. Клиент останавливал загрузку, получив пустой чанк, но если бы он знал размер ожидаемой выборки, то он бы сам знал, когда остановиться. А это было просто, поскольку для отрисовки прогресса мы и так сначала запрашивали размер выборки.</div><div style="text-align: left;"><br /></div><div style="text-align: left;">Сначала мы выбираем только родителей фильтруя по признакам, содержащимся в родителях и ограничивая окном в сто записей: <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">SELECT DISTINCT p.id FROM Parent p WHERE p = ... ORDER BY p.timestamp</span>. Затем полученные идентификаторы м используем во втором запросе никак не ограничивая окно и используя <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">FETCH</span>: <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">SELECT DISTINCT p FROM Parent p LEFT JOIN FETCH p.child c WHERE p.id IN (?) AND c = ... ORDER BY p.timestamp</span>. Это дало нам прирост производительности в пять раз, сократив время формирования отчета до приемлимого уровня.</div><h4 style="text-align: left;">Песочница</h4><div style="text-align: left;">А теперь началось самое интересное: я не смог воспроизвести bottleneck в <a href="http://hg.blzr.me/sandbox">песочнице</a> и <a href="http://www.h2database.com/html/main.html">H2</a> вместо MariaDB. Для бенчмаркинга попробовал использовать <a href="http://www.slf4j.org/extensions.html#profiler">профайлер</a> от SLF4J. Исходники находятся в модуле <a href="http://hg.blzr.me/sandbox/src/default/src/main/java/com/blazer/paging/?at=default">paging</a>. Там запускабельны два класса: <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">PagingApp</span>, замеряющая время выборки с ипользованием Hibernate и <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">Explain </span>выводящую план запроса с аналитикой. Модель состоит из <a href="http://hg.blzr.me/sandbox/src/default/src/main/java/com/blazer/paging/domain/ParentFilter.java?at=default">родителя</a> и <a href="http://hg.blzr.me/sandbox/src/default/src/main/java/com/blazer/paging/domain/ChildFilter.java?at=default">потомка</a> в отношении One-to-Many. База заполняется случайными данными в 100к родителей и 0-10 потомков у каждого.</div><div style="text-align: left;"><br /></div>Профайлинг показал, что <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">FilterBoth+Lim</span> в три раза быстрее, чем <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">FilterBothSmart</span>, хотя должно быть с точностью до наоборот, при этом скорость работы отличается от ожидаемой в десятки раз. <a href="http://hg.blzr.me/sandbox/src/default/src/main/java/com/blazer/paging/PagingApp.java?at=default">Производились</a> следующие замеры:<br />1-2. <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">LJ+Order</span> и <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">LJ+Distinct+Order</span> просто для демонстрации необходимости Distinct<br />3. <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">Fetch+Limit</span> демонстрирует ворнинг <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">HHH000104</span><br />4. <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">LJ+Distinct+Order+Lim</span> просто выборка с окном без фильтрации, этого запроса было достаточно для демонстрации фуллскана<br />5. <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">Filter+Lim</span> выборка с окном и фильтрацией по родителю<br />6. <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">FilterBoth+Lim</span> выборка с окном и фильтрацией по родителю и потомку<br />7. <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">FilterBothSmart</span> сабжевая оптимизация<br />7.1 <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">Prefetch</span> предвыборка первичных ключей с окном<br />7.2 <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">Fetch</span> выборка данных<br /><br /><pre>+ Profiler [Paging]<br />|-- elapsed time                   [init]    78,769  seconds.<br />|-- elapsed time               [LJ+Order]     7,554  seconds.<br />|-- elapsed time      [LJ+Distinct+Order]    12,422  seconds.<br />|-- elapsed time            [Fetch+Limit]    42,375  seconds.<br />|-- elapsed time  [LJ+Distinct+Order+Lim]     0,003  seconds.<br />|-- elapsed time             [Filter+Lim]     0,017  seconds.<br />|-- elapsed time         [FilterBoth+Lim]     0,011  seconds.<br />|---+ Profiler [FilterBothSmart]<br />    |-- elapsed time               [Prefetch]     0,008  seconds.<br />    |-- elapsed time                  [Fetch]     0,024  seconds.<br />    |-- Subtotal            [FilterBothSmart]     0,032  seconds.<br />|-- elapsed time        [FilterBothSmart]     0,032  seconds.<br />|-- Total                        [Paging]   141,194  seconds.<br /></pre><br />У H2 выводит план в совершенно вырвиглазном формате, но понять, в принципе, можно. Хитрожопая база догадывается, что ей достаточно индекса. При этом она и для остальных запросов использовала только индекс. Пришлось в в родителя добавить поле <span style="font-family: &quot;Courier New&quot;,Courier,monospace;">nonIndex</span>, чтобы данные таки были прочитаны с диска - это сильно просадило запросы.<br /><br /><pre>03:01:19,708 DEBUG [main] com.blazer.paging.Explain:16 - LJ+Distinct+Order+Lim<br />03:01:19,725 DEBUG [main] com.blazer.paging.Explain:43 - [SELECT DISTINCT<br />    PARENTFILT0_.ID AS ID1_9_,<br />    PARENTFILT0_.NONINDEX AS NONINDEX2_9_,<br />    PARENTFILT0_.VALUE AS VALUE3_9_<br />FROM PUBLIC.PARENT_FILTER PARENTFILT0_<br />    /* PUBLIC.PARENT_FILTER_VALUE_IDX */<br />    /* scanCount: 10 */<br />LEFT OUTER JOIN PUBLIC.CHILD_FILTER CHILD1_<br />    /* PUBLIC.FK_MXDQ9TND71UF79IQSE2I11ML5_INDEX_4: PARENT_ID = PARENTFILT0_.ID */<br />    ON PARENTFILT0_.ID = CHILD1_.PARENT_ID<br />    /* scanCount: 34 */<br />ORDER BY 3<br />LIMIT ?1<br />/* index sorted */<br />/*<br />total: 21<br />CHILD_FILTER.FK_MXDQ9TND71UF79IQSE2I11ML5_INDEX_4 read: 10 (47%)<br />PARENT_FILTER.PARENT_FILTER_DATA read: 10 (47%)<br />PARENT_FILTER.PARENT_FILTER_VALUE_IDX read: 1 (4%)<br />*/]<br />03:01:19,725 DEBUG [main] com.blazer.paging.Explain:18 - Filter+Lim<br />03:01:19,728 DEBUG [main] com.blazer.paging.Explain:43 - [SELECT DISTINCT<br />    PARENTFILT0_.ID AS ID1_9_,<br />    PARENTFILT0_.NONINDEX AS NONINDEX2_9_,<br />    PARENTFILT0_.VALUE AS VALUE3_9_<br />FROM PUBLIC.PARENT_FILTER PARENTFILT0_<br />    /* PUBLIC.PARENT_FILTER_VALUE_IDX: VALUE &gt;= ?2<br />        AND VALUE &lt;= ?3<br />     */<br />    /* WHERE (PARENTFILT0_.VALUE &gt;= ?2)<br />        AND (PARENTFILT0_.VALUE &lt;= ?3)<br />    */<br />    /* scanCount: 10 */<br />LEFT OUTER JOIN PUBLIC.CHILD_FILTER CHILD1_<br />    /* PUBLIC.FK_MXDQ9TND71UF79IQSE2I11ML5_INDEX_4: PARENT_ID = PARENTFILT0_.ID */<br />    ON PARENTFILT0_.ID = CHILD1_.PARENT_ID<br />    /* scanCount: 34 */<br />WHERE (PARENTFILT0_.VALUE &gt;= ?2)<br />    AND (PARENTFILT0_.VALUE &lt;= ?3)<br />ORDER BY 3<br />LIMIT ?1<br />/* index sorted */]<br />03:01:19,728 DEBUG [main] com.blazer.paging.Explain:20 - FilterBoth+Lim<br />03:01:19,732 DEBUG [main] com.blazer.paging.Explain:43 - [SELECT DISTINCT<br />    PARENTFILT0_.ID AS ID1_9_,<br />    PARENTFILT0_.NONINDEX AS NONINDEX2_9_,<br />    PARENTFILT0_.VALUE AS VALUE3_9_<br />FROM PUBLIC.PARENT_FILTER PARENTFILT0_<br />    /* PUBLIC.PARENT_FILTER_VALUE_IDX: VALUE &gt;= ?2<br />        AND VALUE &lt;= ?3<br />     */<br />    /* WHERE (PARENTFILT0_.VALUE &gt;= ?2)<br />        AND (PARENTFILT0_.VALUE &lt;= ?3)<br />    */<br />    /* scanCount: 10 */<br />LEFT OUTER JOIN PUBLIC.CHILD_FILTER CHILD1_<br />    /* PUBLIC.FK_MXDQ9TND71UF79IQSE2I11ML5_INDEX_4: PARENT_ID = PARENTFILT0_.ID */<br />    ON PARENTFILT0_.ID = CHILD1_.PARENT_ID<br />    /* scanCount: 34 */<br />WHERE ((PARENTFILT0_.VALUE &gt;= ?2)<br />    AND (PARENTFILT0_.VALUE &lt;= ?3))<br />    AND ((CHILD1_.VALUE &gt;= ?4)<br />    AND (CHILD1_.VALUE &lt;= ?5))<br />ORDER BY 3<br />LIMIT ?1<br />/* index sorted */<br />/*<br />total: 11<br />CHILD_FILTER.CHILD_FILTER_DATA read: 11 (100%)<br />*/]<br />03:01:19,732 DEBUG [main] com.blazer.paging.Explain:22 - FilterBothSmart Prefetch<br />03:01:19,736 DEBUG [main] com.blazer.paging.Explain:43 - [SELECT<br />    PARENTFILT0_.ID AS COL_0_0_,<br />    PARENTFILT0_.VALUE AS COL_1_0_<br />FROM PUBLIC.PARENT_FILTER PARENTFILT0_<br />    /* PUBLIC.PARENT_FILTER_VALUE_IDX: VALUE &gt;= ?2<br />        AND VALUE &lt;= ?3<br />     */<br />    /* scanCount: 10 */<br />WHERE (PARENTFILT0_.VALUE &gt;= ?2)<br />    AND (PARENTFILT0_.VALUE &lt;= ?3)<br />ORDER BY 2<br />LIMIT ?1<br />/* index sorted */]<br />03:01:19,736 DEBUG [main] com.blazer.paging.Explain:24 - FilterBothSmart Fetch<br />03:01:19,740 DEBUG [main] com.blazer.paging.Explain:43 - [SELECT DISTINCT<br />    PARENTFILT0_.ID AS ID1_9_,<br />    PARENTFILT0_.NONINDEX AS NONINDEX2_9_,<br />    PARENTFILT0_.VALUE AS VALUE3_9_<br />FROM PUBLIC.PARENT_FILTER PARENTFILT0_<br />    /* PUBLIC.PRIMARY_KEY_6: ID IN(?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10) */<br />    /* WHERE PARENTFILT0_.ID IN(?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10)<br />    */<br />    /* scanCount: 11 */<br />LEFT OUTER JOIN PUBLIC.CHILD_FILTER CHILD1_<br />    /* PUBLIC.FK_MXDQ9TND71UF79IQSE2I11ML5_INDEX_4: PARENT_ID = PARENTFILT0_.ID */<br />    ON PARENTFILT0_.ID = CHILD1_.PARENT_ID<br />    /* scanCount: 35 */<br />WHERE (PARENTFILT0_.ID IN(?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9, ?10))<br />    AND ((CHILD1_.VALUE &gt;= ?11)<br />    AND (CHILD1_.VALUE &lt;= ?12))<br />ORDER BY 3<br />/*<br />total: 1<br />PARENT_FILTER.PARENT_FILTER_DATA read: 1 (100%)<br />*/]<br /></pre><br />Итог: странная ситуация и в песочнице не хватает какого-то ключевого фактора либо методические ошибки: может мешает кэш, но как его просто отключить я не вкурил.</div>