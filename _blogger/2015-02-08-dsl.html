---
layout: post
title: Про языки и DSL
date: '2015-02-09T01:17:00.001+06:00'
author: Constantine Linnick
tags:
- работа
- development
- epiphany
modified_time: '2015-02-09T01:17:27.401+06:00'
thumbnail: http://1.bp.blogspot.com/-MatJpJIB6IM/VNeQ8p1Xa_I/AAAAAAAACwo/setkHCj8nWo/s72-c/Screenshot%2Bfrom%2B2015-02-08%2B22%3A18%3A59.png
blogger_id: tag:blogger.com,1999:blog-372595778394672936.post-5970463484720695818
blogger_orig_url: http://blog.blzr.me/2015/02/dsl.html
---

<div dir="ltr" style="text-align: left;" trbidi="on">Я уже как-то писал про <a href="http://blog.blzr.me/2013/11/blog-post_27.html">инсайты</a>, приходящие именно в тот момент, когда ты готов услышать их. Хотя большой вопрос: каков вклад счастливой случайности? Может это знание, как тайные знаки всегда было рядом, а ты их смог увидеть и понять, только когда стал готов, а случай подвернется рано или поздно.<br /><a name='more'></a><br /><h4 style="text-align: left;">Embedded. Сначала был Diablo</h4><div style="text-align: left;">Было это в беззаботные студенческие времена (лет 8 назад): кореш поднял у себя на работе батл.нет и мы в сободное от безделья время зарубались в Diablo II. Довольно быстро мне надоело тупо фармить и захотелось разнообразия - был найден D2jsp (java script parser) и за пару дней непрерывной работы бота герои для обмена вещами были под завязку забиты уникальными вещами на любой вкус. Исход немного предсказуем - дальше играть стало совершенно неинтересно (gameplay was ruined by cheater). Тем не менее, мне стало интересно, как устроен бот и я немного поковырял скрипты. JS я на тот момент более менее понимал и тут меня капитально накрыло: язык общего пользования, в котором доступно API для взаимодействия в интерфейсом игры, доменная модель для получения информации о персонаже. После этого я по-новому взглянул на DOM API, предоставляемый браузером и на XMLHttpRequest. Как это делается я узнал сильно позже, но на тот момент этого было достаточно для неизгладимого впечатления.</div><div style="text-align: left;"><br /></div><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-MatJpJIB6IM/VNeQ8p1Xa_I/AAAAAAAACwo/setkHCj8nWo/s1600/Screenshot%2Bfrom%2B2015-02-08%2B22%3A18%3A59.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://1.bp.blogspot.com/-MatJpJIB6IM/VNeQ8p1Xa_I/AAAAAAAACwo/setkHCj8nWo/s1600/Screenshot%2Bfrom%2B2015-02-08%2B22%3A18%3A59.png" height="374" width="640" /></a></div><h4 style="text-align: left;">Lex/AWK и конфиги</h4><div style="text-align: left;">Первая работа окунула меня с головой во FreeBSD 5 или 6, где гуй KDE 3.5 нужно было запускать командой startx. Конфиги для Esomo парсились через <a href="http://en.wikipedia.org/wiki/Lex_%28software%29">Lex</a>, <a href="http://en.wikipedia.org/wiki/AWK">AWK</a> тоже вроде использовался для каких-то внутренних нужно, суть одна - набор правил, описанных регулярными выражениями. Они не воспринимались как что-то крутое, рабочие утилитарные инструменты. Очень часто этого не хватало на винде, люди вынуждены извращаться, портирование не помогает из-за проблем с консольными кодировками (как там дела обстоят в 8-ке и старше я не знаю).</div><h4 style="text-align: left;">JavaCC и Excel</h4><div style="text-align: left;">Мы делали супе-пупер универсальный инструмент для сбора и консолидации данных. Проблема была в том, что у нас было 4 вида формул: вычисления на текущем листе (аналог excel), агрегатные вычисления на листе (sum,max,min,avg etc.), агрегатные функции поверх множества отчетов сданных за разный период и вычисления с использованием результатов агрегатных функций. Все это делалось при помощи SQL, но в один прекрасный момент захотелось динамизма: довольно глупо в вебе рисовать аналог excel и жать кнопку сохранить, чтобы пересчитать сумму в колонке. Были написаны аналоги SQL функций на JS (тут я вспомнил d2jsp).</div><div style="text-align: left;"><br /></div><div style="text-align: left;">Следущим очевидным шагом было написание языка, который транслируется в SQL (выбирая данные из таблиц) и JS (который работает с массивами). Взяли старый и проверенный <a href="http://en.wikipedia.org/wiki/JavaCC">javacc</a> - после Lex и AWK воспринималось на ура, просто java диалект проверенных временем технологий. Мы взяли готовую грамматику для plsql (поскольку он был основной целью и совпадал на 95% с исходником) и доточили для своих нужд. Совершенно бесплатно получили еще и проверку синтаксиса. Короче, писать свои языки, особенно если брать готовые грамматики - оказалось очень просто.</div><div style="text-align: left;"><br /></div><div style="text-align: left;">Кстати, когда писал проверку на наличие циклических зависимостей в формулах и порядка вычисления формул вспомнилась задачка со второго курса на вычисления порядка закрытия станций метро, чтобы не потерять связности графа.</div><h4 style="text-align: left;">Fluent API</h4><div style="text-align: left;">Второй раз <a href="http://blog.blzr.me/2014/03/api.html">накрыло</a>, когда зачем-то ковырял <a href="https://code.google.com/p/guava-libraries/wiki/ImmutableCollectionsExplained">Guava</a>. Обладая небогатым инструментарием из анонимных, inline-классов и vararg-аргументов строится красивейший API на билдерах. Реально пирдуха, простейшая по-сути вещь, ретроспективно очевидная как колесо, после такого хочется выбросить половину своего кода и переписать его на fluent API.</div><h4 style="text-align: left;">Groovy DSL</h4><div style="text-align: left;">Groovy - это язык, который хочет казаться DSL надстройкой над java. <i>У нас был простой синтаксис, где точка с запятой и скобки необязательны, легко можно пердавать замыкания в качестве параметра и целое множество аннотаций всех сортов и расцветок. Не то что бы это был необходимый запас для создания DSL. Но если начал собирать метаинструменты, становится трудно остановиться. Единственное что вызывало у меня опасение - это AST-трансформации. Нет ничего более беспомощного, безответственного и испорченного, чем макро зомби. Я знал, что рано или поздно мы перейдем и на эту дрянь.</i></div><div style="text-align: left;"><br /></div><div style="text-align: left;">Шутки шутками, но на данный момент groovy видится как терминальная стадия - это тот инструмент, который я буду использовать в первую очередь. Как определить успешность DSL? - им начинают пользоваться люди от бизнеса (непередаваемое ощущение, когда тебе говорят в строке 5 неправильно рассчитывается прибыль): excel тут пример оглушительного успеха, а SQL пример такого же оглушительного провала этой затеи. Неотъемлимыми качествами являются: синтаксис, который может понять человек далекий от программирования (без императивщины, модульного программирования, рекурсии, циклов), обратная связь (валидация синтаксиса, понятные ошибки с примерами) и запуск даблкликом без танцев с тулчейном - все это есть в groovy. Очень многое в языке завернуто в DSL - в качестве примера можно посмотреть на <a href="http://grails.github.io/grails-doc/latest/guide/GORM.html#criteria">Criteria</a> в GORM (хотя реализация с точки зрения использования ужасна).</div></div>